name: Toolify Data Collection

on:
  schedule:
    # 每月2号凌晨2点执行 (UTC时间)
    - cron: '0 2 2 * *'
  workflow_dispatch:  # 支持手动触发
    inputs:
      target_count:
        description: '采集目标数量'
        required: false
        default: '3000'
        type: string
      quick_test:
        description: '快速测试模式 (使用模拟数据)'
        required: false
        default: false
        type: boolean

jobs:
  collect:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install Python dependencies
        run: |
          echo "📦 开始安装Python依赖包..."
          echo "🔄 升级pip..."
          python -m pip install --upgrade pip --timeout 60

          echo "📋 安装依赖包（带超时和进度显示）..."
          pip install --timeout 300 --verbose -r requirements.txt

          echo "✅ Python依赖安装完成"
          echo "📊 已安装的包列表:"
          pip list | grep -E "(selenium|requests|webdriver-manager|python-dotenv)"

      - name: Install Chrome and ChromeDriver
        timeout-minutes: 10
        run: |
          echo "🌐 开始安装Chrome浏览器..."
          sudo apt-get update -q
          sudo apt-get install -y google-chrome-stable unzip wget

          echo "✅ Chrome安装完成"
          google-chrome --version

          # 获取Chrome版本
          CHROME_VERSION=$(google-chrome --version | grep -oE '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+' | head -1)
          MAJOR_VERSION=$(echo $CHROME_VERSION | cut -d. -f1)
          echo "Chrome version: $CHROME_VERSION"
          echo "Chrome major version: $MAJOR_VERSION"

          # 尝试安装ChromeDriver（多种方法）
          # 方法1: 使用apt安装（最简单）
          if sudo apt-get install -y chromium-chromedriver; then
            echo "✅ 使用apt安装ChromeDriver成功"
            sudo ln -sf /usr/bin/chromedriver /usr/local/bin/chromedriver 2>/dev/null || true
          else
            echo "⚠️ apt安装失败，尝试手动下载..."

            # 方法2: 手动下载稳定版本
            CHROMEDRIVER_VERSION="120.0.6099.109"
            echo "Using ChromeDriver version: $CHROMEDRIVER_VERSION"

            DOWNLOAD_URL="https://chromedriver.storage.googleapis.com/$CHROMEDRIVER_VERSION/chromedriver_linux64.zip"
            echo "Download URL: $DOWNLOAD_URL"

            if wget -O /tmp/chromedriver.zip "$DOWNLOAD_URL"; then
              sudo unzip /tmp/chromedriver.zip -d /tmp/
              sudo mv /tmp/chromedriver /usr/local/bin/chromedriver
              sudo chmod +x /usr/local/bin/chromedriver
            else
              echo "❌ ChromeDriver下载失败，尝试使用webdriver-manager"
            fi
          fi

          # 验证ChromeDriver是否可用
          if [ -f "/usr/local/bin/chromedriver" ]; then
            echo "✅ ChromeDriver安装成功:"
            ls -la /usr/local/bin/chromedriver
            /usr/local/bin/chromedriver --version
          elif [ -f "/usr/bin/chromedriver" ]; then
            echo "✅ 使用系统ChromeDriver:"
            ls -la /usr/bin/chromedriver
            /usr/bin/chromedriver --version
          else
            echo "⚠️ ChromeDriver安装可能有问题，将依赖webdriver-manager"
          fi

      - name: Setup Chrome for headless mode
        run: |
          # 创建scripts目录
          mkdir -p scripts
          # 创建优化的采集器脚本
          cat > scripts/production-collector.py << 'EOF'
          #!/usr/bin/env python3
          """
          生产环境Toolify数据采集器
          """
          print("🚀 Python脚本开始执行...")
          print("📦 开始导入模块...")

          import os
          print("✅ os 模块导入成功")
          import time
          print("✅ time 模块导入成功")
          import json
          print("✅ json 模块导入成功")
          import requests
          print("✅ requests 模块导入成功")
          from datetime import datetime
          print("✅ datetime 模块导入成功")
          from selenium import webdriver
          print("✅ selenium webdriver 模块导入成功")
          from selenium.webdriver.common.by import By
          print("✅ selenium By 模块导入成功")
          from selenium.webdriver.support.ui import WebDriverWait
          print("✅ selenium WebDriverWait 模块导入成功")
          from selenium.webdriver.support import expected_conditions as EC
          print("✅ selenium expected_conditions 模块导入成功")
          from selenium.webdriver.chrome.service import Service
          print("✅ selenium Service 模块导入成功")
          from webdriver_manager.chrome import ChromeDriverManager
          print("✅ webdriver_manager 模块导入成功")

          print("🎯 所有模块导入完成，开始定义函数...")

          def setup_driver():
              """设置Chrome浏览器 - 生产环境优化版本"""
              options = webdriver.ChromeOptions()

              # 生产环境Chrome设置
              options.add_argument("--headless")
              options.add_argument("--no-sandbox")
              options.add_argument("--disable-dev-shm-usage")
              options.add_argument("--disable-gpu")
              options.add_argument("--disable-web-security")
              options.add_argument("--disable-features=VizDisplayCompositor")
              options.add_argument("--window-size=1920,1080")
              options.add_argument("--lang=zh-CN")

              # 反检测设置
              options.add_argument("--disable-blink-features=AutomationControlled")
              options.add_argument("--disable-extensions")
              options.add_experimental_option("excludeSwitches", ["enable-automation"])
              options.add_experimental_option('useAutomationExtension', False)

              # 更真实的用户代理
              user_agent = "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
              options.add_argument(f"--user-agent={user_agent}")

              try:
                  # 尝试多种ChromeDriver安装方法
                  driver_path = None

                  try:
                      # 方法1: 优先使用系统安装的ChromeDriver
                      system_paths = ["/usr/local/bin/chromedriver", "/usr/bin/chromedriver"]
                      for path in system_paths:
                          if os.path.exists(path):
                              driver_path = path
                              print(f"📦 使用系统ChromeDriver: {driver_path}")
                              break

                      if not driver_path:
                          # 方法2: 使用webdriver-manager作为备选
                          print("🔄 使用webdriver-manager下载ChromeDriver...")
                          driver_path = ChromeDriverManager().install()
                          print(f"📦 ChromeDriver路径: {driver_path}")

                          # 确保有执行权限
                          import stat
                          current_permissions = os.stat(driver_path).st_mode
                          os.chmod(driver_path, current_permissions | stat.S_IEXEC)
                          print("✅ ChromeDriver权限已设置")

                  except Exception as e:
                      print(f"⚠️ ChromeDriver设置失败: {e}")
                      driver_path = "chromedriver"  # 最后尝试PATH中的chromedriver

                  service = Service(driver_path)
                  driver = webdriver.Chrome(service=service, options=options)
                  driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")
                  print("✅ Chrome浏览器启动成功")
                  return driver

              except Exception as e:
                  print(f"❌ Chrome启动失败: {e}")
                  print(f"🔍 错误类型: {type(e).__name__}")
                  import traceback
                  print(f"📋 详细错误: {traceback.format_exc()}")
                  return None

          def get_settings_from_db():
              """从数据库获取采集设置"""
              print("🏗️ get_settings_from_db 函数开始")
              try:
                  print("📦 导入requests模块...")
                  import requests

                  print("🔍 获取环境变量...")
                  url = os.getenv('SUPABASE_URL')
                  key = os.getenv('SUPABASE_ANON_KEY')
                  print(f"📊 环境变量状态: URL={bool(url)}, KEY={bool(key)}")

                  if not url or not key:
                      print("⚠️ 数据库配置缺失，使用默认设置")
                      return {
                          'target_count': 3000,
                          'enabled': True,
                          'max_scroll_attempts': 60,
                          'batch_size': 100,
                          'retry_attempts': 3
                      }

                  # 清理环境变量中的无效字符和GitHub标记
                  url = url.strip()
                  key = key.strip()

                  # 移除可能的GitHub标记
                  if '***' in key:
                      print("⚠️ 检测到GitHub标记，尝试清理...")
                      key = key.replace('***', '')

                  # 移除其他可能的无效字符
                  import re
                  key = re.sub(r'[^\w\-\.]', '', key)  # 只保留字母数字和.-_

                  print(f"🔗 连接数据库: {url[:50]}...")
                  print(f"🔑 密钥长度: {len(key)} 字符")
                  print(f"🔑 密钥开头: {key[:10]}...")
                  print(f"🔑 密钥结尾: ...{key[-10:]}")

                  headers = {
                      'apikey': key,
                      'Authorization': f'Bearer {key}',
                      'Content-Type': 'application/json'
                  }

                  response = requests.get(f'{url}/rest/v1/system_settings', headers=headers)

                  if response.status_code == 200:
                      settings_data = response.json()
                      settings = {}

                      for setting in settings_data:
                          key_name = setting['setting_key']
                          value = setting['setting_value']

                          # 类型转换
                          if setting['setting_type'] == 'number':
                              value = int(value)
                          elif setting['setting_type'] == 'boolean':
                              value = value.lower() == 'true'

                          settings[key_name] = value

                      return {
                          'target_count': settings.get('collection_target_count', 3000),
                          'enabled': settings.get('collection_enabled', True),
                          'max_scroll_attempts': settings.get('max_scroll_attempts', 60),
                          'batch_size': settings.get('batch_size', 100),
                          'retry_attempts': settings.get('retry_attempts', 3)
                      }
                  else:
                      print(f"⚠️ 获取设置失败: {response.status_code}")
                      return {
                          'target_count': 3000,
                          'enabled': True,
                          'max_scroll_attempts': 60,
                          'batch_size': 100,
                          'retry_attempts': 3
                      }
              except Exception as e:
                  print(f"⚠️ 获取设置出错: {e}")
                  return {
                      'target_count': 3000,
                      'enabled': True,
                      'max_scroll_attempts': 60,
                      'batch_size': 100,
                      'retry_attempts': 3
                  }

          def collect_toolify_data(target_count=3000, max_scroll_attempts=60):
              """采集Toolify数据"""
              print(f"🚀 开始采集最多 {target_count} 条工具数据...")

              driver = setup_driver()
              if not driver:
                  return []

              tools_data = []

              try:
                  url = "https://www.toolify.ai/zh/Best-trending-AI-Tools"
                  print(f"📱 正在访问: {url}")

                  driver.get(url)

                  print("⏳ 等待页面完全加载...")
                  time.sleep(5)

                  # 检查页面是否正确加载
                  page_title = driver.title
                  print(f"📄 页面标题: {page_title}")

                  # 检查是否有数据表格
                  try:
                      initial_rows = driver.find_elements(By.CSS_SELECTOR, "tr.el-table__row")
                      print(f"🔍 初始加载发现 {len(initial_rows)} 行数据")
                      if len(initial_rows) == 0:
                          print("⚠️ 警告：未发现数据行，页面可能未正确加载")
                          # 尝试等待更长时间
                          print("⏳ 再等待5秒...")
                          time.sleep(5)
                          initial_rows = driver.find_elements(By.CSS_SELECTOR, "tr.el-table__row")
                          print(f"🔍 重新检查发现 {len(initial_rows)} 行数据")
                  except Exception as e:
                      print(f"❌ 检查初始数据时出错: {e}")
                  time.sleep(10)  # 增加等待时间

                  print("🔍 开始数据采集...")

                  scroll_attempts = 0
                  max_scroll_attempts = 60  # 最多滚动60次
                  no_new_data_count = 0

                  while len(tools_data) < target_count and scroll_attempts < max_scroll_attempts:
                      try:
                          print(f"📊 第{scroll_attempts + 1}次滚动 - 当前已采集: {len(tools_data)}/{target_count} 条")

                          current_rows = driver.find_elements(By.CSS_SELECTOR, "tr.el-table__row")

                          if not current_rows:
                              print("⚠️ 未找到数据行，等待页面加载...")
                              time.sleep(3)  # 减少等待时间
                              scroll_attempts += 1
                              continue

                          print(f"🔍 页面当前显示 {len(current_rows)} 行数据")

                          # 提取新数据
                          initial_count = len(tools_data)
                          for i in range(len(tools_data), min(len(current_rows), target_count)):
                              try:
                                  row = current_rows[i]

                                  # 提取工具数据
                                  tool_link = row.find_element(By.CSS_SELECTOR, ".go-tool")
                                  tool_name = tool_link.text.strip()
                                  tool_url = tool_link.get_attribute("href")

                                  cells = row.find_elements(By.TAG_NAME, "td")

                                  tool_data = {
                                      "ranking": i + 1,
                                      "tool_name": tool_name,
                                      "tool_url": f"https://www.toolify.ai{tool_url}" if tool_url.startswith("/") else tool_url,
                                      "monthly_visits": cells[2].find_element(By.TAG_NAME, "span").text.strip() if len(cells) > 2 else "",
                                      "growth": cells[3].find_element(By.TAG_NAME, "span").text.strip() if len(cells) > 3 else "",
                                      "growth_rate": cells[4].find_element(By.TAG_NAME, "span").text.strip() if len(cells) > 4 else "",
                                      "description": cells[5].find_element(By.TAG_NAME, "p").text.strip() if len(cells) > 5 else "",
                                      "tags": cells[6].find_element(By.TAG_NAME, "p").text.strip() if len(cells) > 6 else "",
                                      "collected_at": datetime.now().isoformat(),
                                      "collection_batch": f"github-actions-{datetime.now().strftime('%Y-%m-%d')}"
                                  }

                                  tools_data.append(tool_data)

                                  if len(tools_data) % 50 == 0:
                                      print(f"📊 已采集 {len(tools_data)} 条数据...")

                              except Exception as e:
                                  print(f"❌ 提取第{i+1}行数据失败: {e}")

                          # 检查是否有新数据
                          new_data_count = len(tools_data) - initial_count
                          if new_data_count > 0:
                              print(f"✅ 本次滚动新增 {new_data_count} 条数据")
                              no_new_data_count = 0
                          else:
                              no_new_data_count += 1
                              print(f"⚠️ 本次滚动无新数据 (连续{no_new_data_count}次)")
                              if no_new_data_count >= 3:
                                  print("🛑 连续多次无新数据，停止采集")
                                  break

                          # 如果达到目标数量，退出
                          if len(tools_data) >= target_count:
                              print(f"🎉 已达到目标数量 {target_count} 条！")
                              break

                          # 智能滚动策略
                          print(f"🔄 执行滚动策略...")

                          if scroll_attempts % 3 == 0:
                              print("📜 滚动到页面底部")
                              driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
                          elif scroll_attempts % 3 == 1:
                              print("📜 向下滚动3000像素")
                              driver.execute_script("window.scrollBy(0, 3000);")
                          else:
                              print("📜 滚动到底部后回滚200像素")
                              driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
                              time.sleep(1)
                              driver.execute_script("window.scrollBy(0, -200);")

                          print("⏳ 等待页面加载...")
                          time.sleep(4)  # 减少等待时间从8秒到4秒
                          scroll_attempts += 1

                      except Exception as e:
                          print(f"❌ 滚动采集出错: {e}")
                          scroll_attempts += 1
                          time.sleep(5)

                  print(f"✅ 采集完成！共获取 {len(tools_data)} 条数据")

                  # 输出采集数据样本用于调试
                  if tools_data:
                      print("📋 采集数据样本（前3条）:")
                      for i, tool in enumerate(tools_data[:3]):
                          print(f"   {i+1}. {tool.get('tool_name', 'N/A')} - {tool.get('monthly_visits', 'N/A')}")

                  return tools_data[:target_count]

              except Exception as e:
                  print(f"❌ 采集过程出错: {e}")
                  return tools_data

              finally:
                  print("🔚 关闭浏览器...")
                  driver.quit()

          def upload_to_supabase(tools_data):
              """上传数据到Supabase - 改进版UPSERT逻辑"""
              if not tools_data:
                  print("❌ 没有数据需要上传")
                  return False

              url = os.getenv('SUPABASE_URL')
              key = os.getenv('SUPABASE_ANON_KEY')

              if not url or not key:
                  print("❌ Supabase配置缺失")
                  print(f"   SUPABASE_URL: {'✅ 已设置' if url else '❌ 未设置'}")
                  print(f"   SUPABASE_ANON_KEY: {'✅ 已设置' if key else '❌ 未设置'}")
                  return False

              # 清理环境变量
              url = url.strip()
              key = key.strip()

              print(f"📤 准备上传 {len(tools_data)} 条数据到: {url[:50]}...")
              print(f"🔑 API密钥长度: {len(key)} 字符")

              # 先测试连接
              test_headers = {
                  'apikey': key,
                  'Authorization': f'Bearer {key}',
                  'Content-Type': 'application/json'
              }

              try:
                  print("🔍 测试数据库连接...")
                  test_response = requests.get(f'{url}/rest/v1/toolify_tools?limit=1', headers=test_headers, timeout=10)
                  print(f"📊 连接测试响应: {test_response.status_code}")

                  if test_response.status_code != 200:
                      print(f"❌ 数据库连接失败: {test_response.text}")
                      return False
                  else:
                      print("✅ 数据库连接正常")
              except Exception as e:
                  print(f"❌ 数据库连接异常: {e}")
                  return False

              # 使用单条UPSERT确保数据正确插入
              success_count = 0
              error_count = 0

              for i, tool in enumerate(tools_data):
                  try:
                      # 为每个工具执行单独的UPSERT操作
                      upsert_headers = {
                          'apikey': key,
                          'Authorization': f'Bearer {key}',
                          'Content-Type': 'application/json',
                          'Prefer': 'resolution=merge-duplicates'
                      }

                      response = requests.post(
                          f'{url}/rest/v1/toolify_tools',
                          headers=upsert_headers,
                          json=tool,
                          timeout=30
                      )

                      if response.status_code in [200, 201]:
                          success_count += 1
                          if (i + 1) % 50 == 0:
                              print(f"📊 已处理 {i + 1}/{len(tools_data)} 条数据...")
                      elif response.status_code == 409:
                          # 如果遇到冲突，尝试更新现有记录
                          try:
                              update_headers = {
                                  'apikey': key,
                                  'Authorization': f'Bearer {key}',
                                  'Content-Type': 'application/json'
                              }

                              update_response = requests.patch(
                                  f'{url}/rest/v1/toolify_tools?tool_name=eq.{tool["tool_name"]}',
                                  headers=update_headers,
                                  json=tool,
                                  timeout=30
                              )

                              if update_response.status_code in [200, 204]:
                                  success_count += 1
                                  if (i + 1) % 50 == 0:
                                      print(f"📊 已更新 {i + 1}/{len(tools_data)} 条数据...")
                              else:
                                  error_count += 1
                                  print(f"❌ 更新失败 {tool['tool_name']}: {update_response.status_code} {update_response.text}")
                          except Exception as update_e:
                              error_count += 1
                              print(f"❌ 更新异常 {tool['tool_name']}: {update_e}")
                      else:
                          error_count += 1
                          print(f"❌ 上传失败 {tool['tool_name']}: {response.status_code} {response.text}")

                  except Exception as e:
                      error_count += 1
                      print(f"❌ 处理异常 {tool.get('tool_name', 'Unknown')}: {e}")

              print(f"📊 上传完成统计:")
              print(f"   ✅ 成功: {success_count} 条")
              print(f"   ❌ 失败: {error_count} 条")
              print(f"   📈 成功率: {success_count/(success_count+error_count)*100:.1f}%")

              # 只要有部分成功就认为任务成功
              return success_count > 0

          def main():
              print("🔥 main函数开始执行")
              print("=" * 50)
              print("🎯 Toolify生产环境数据采集")
              print("=" * 50)

              print("🔗 准备从数据库获取设置...")
              # 从数据库获取设置
              settings = get_settings_from_db()
              print("✅ 数据库设置获取完成")
              print(f"📋 采集设置: {settings}")

              # 检查是否是手动触发
              manual_target = os.getenv('INPUT_TARGET_COUNT')
              if manual_target:
                  print(f"🎯 手动触发，目标数量: {manual_target}")
                  target_count = int(manual_target)
                  max_scroll_attempts = settings['max_scroll_attempts']
              else:
                  # 自动执行，检查是否启用
                  if not settings['enabled']:
                      print("⏸️ 定时采集已禁用，跳过执行")
                      return

                  target_count = settings['target_count']
                  max_scroll_attempts = settings['max_scroll_attempts']

              print(f"🎯 最终采集目标: {target_count} 条")

              # 采集数据
              tools_data = collect_toolify_data(
                  target_count=target_count,
                  max_scroll_attempts=max_scroll_attempts
              )

              if not tools_data:
                  print("💥 采集失败，没有获取到数据")
                  exit(1)

              # 保存本地备份
              backup_file = f"./toolify-backup-{datetime.now().strftime('%Y-%m-%d')}.json"
              with open(backup_file, 'w', encoding='utf-8') as f:
                  json.dump(tools_data, f, ensure_ascii=False, indent=2)
              print(f"💾 本地备份已保存: {backup_file}")

              # 上传到Supabase
              upload_success = upload_to_supabase(tools_data)

              if upload_success:
                  print("🎉 数据采集和上传任务完成！")
              else:
                  print("💥 数据上传失败")
                  exit(1)

          if __name__ == "__main__":
              print("🎬 进入main函数...")
              main()
              print("🏁 main函数执行完成")
          EOF

      - name: Run data collection
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}
          INPUT_TARGET_COUNT: ${{ github.event.inputs.target_count }}
        run: |
          echo "🔧 环境变量检查:"
          echo "   TARGET_COUNT输入: ${{ github.event.inputs.target_count }}"
          echo "   INPUT_TARGET_COUNT: $INPUT_TARGET_COUNT"
          echo "   QUICK_TEST模式: ${{ github.event.inputs.quick_test }}"

          if [ "${{ github.event.inputs.quick_test }}" = "true" ]; then
            echo "🧪 运行快速测试模式..."
            python scripts/quick-test-collector.py
          else
            echo "🔄 运行完整数据采集..."
            python scripts/production-collector.py
          fi

      - name: Upload backup on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: collection-backup-${{ github.run_number }}
          path: ./toolify-backup-*.json
          retention-days: 30
          if-no-files-found: ignore

      - name: Notify on success
        if: success()
        run: |
          echo "✅ 数据采集成功完成于 $(date)"
          echo "📊 查看最新数据: https://your-toolify-app.vercel.app"

      - name: Notify on failure
        if: failure()
        run: |
          echo "❌ 数据采集失败于 $(date)"
          echo "📋 请检查日志和备份文件"