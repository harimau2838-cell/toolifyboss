name: Toolify Data Collection

on:
  schedule:
    # æ¯æœˆ2å·å‡Œæ™¨2ç‚¹æ‰§è¡Œ (UTCæ—¶é—´)
    - cron: '0 2 2 * *'
  workflow_dispatch:  # æ”¯æŒæ‰‹åŠ¨è§¦å‘

jobs:
  collect:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install Python dependencies
        run: |
          pip install selenium webdriver-manager requests python-dotenv

      - name: Install Chrome
        run: |
          sudo apt-get update
          sudo apt-get install -y google-chrome-stable

      - name: Setup Chrome for headless mode
        run: |
          # åˆ›å»ºä¼˜åŒ–çš„é‡‡é›†å™¨è„šæœ¬
          cat > scripts/production-collector.py << 'EOF'
          #!/usr/bin/env python3
          """
          ç”Ÿäº§ç¯å¢ƒToolifyæ•°æ®é‡‡é›†å™¨
          """
          import os
          import time
          import json
          import requests
          from datetime import datetime
          from selenium import webdriver
          from selenium.webdriver.common.by import By
          from selenium.webdriver.support.ui import WebDriverWait
          from selenium.webdriver.support import expected_conditions as EC
          from selenium.webdriver.chrome.service import Service
          from webdriver_manager.chrome import ChromeDriverManager

          def setup_driver():
              """è®¾ç½®Chromeæµè§ˆå™¨ - ç”Ÿäº§ç¯å¢ƒä¼˜åŒ–ç‰ˆæœ¬"""
              options = webdriver.ChromeOptions()

              # ç”Ÿäº§ç¯å¢ƒChromeè®¾ç½®
              options.add_argument("--headless")
              options.add_argument("--no-sandbox")
              options.add_argument("--disable-dev-shm-usage")
              options.add_argument("--disable-gpu")
              options.add_argument("--disable-web-security")
              options.add_argument("--disable-features=VizDisplayCompositor")
              options.add_argument("--window-size=1920,1080")
              options.add_argument("--lang=zh-CN")

              # åæ£€æµ‹è®¾ç½®
              options.add_argument("--disable-blink-features=AutomationControlled")
              options.add_argument("--disable-extensions")
              options.add_experimental_option("excludeSwitches", ["enable-automation"])
              options.add_experimental_option('useAutomationExtension', False)

              # æ›´çœŸå®çš„ç”¨æˆ·ä»£ç†
              user_agent = "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
              options.add_argument(f"--user-agent={user_agent}")

              try:
                  service = Service(ChromeDriverManager().install())
                  driver = webdriver.Chrome(service=service, options=options)
                  driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")
                  return driver
              except Exception as e:
                  print(f"âŒ Chromeå¯åŠ¨å¤±è´¥: {e}")
                  return None

          def get_settings_from_db():
              """ä»æ•°æ®åº“è·å–é‡‡é›†è®¾ç½®"""
              try:
                  import requests

                  url = os.getenv('SUPABASE_URL')
                  key = os.getenv('SUPABASE_ANON_KEY')

                  if not url or not key:
                      print("âš ï¸ æ•°æ®åº“é…ç½®ç¼ºå¤±ï¼Œä½¿ç”¨é»˜è®¤è®¾ç½®")
                      return {
                          'target_count': 3000,
                          'enabled': True,
                          'max_scroll_attempts': 60,
                          'batch_size': 100,
                          'retry_attempts': 3
                      }

                  headers = {
                      'apikey': key,
                      'Authorization': f'Bearer {key}',
                      'Content-Type': 'application/json'
                  }

                  response = requests.get(f'{url}/rest/v1/system_settings', headers=headers)

                  if response.status_code == 200:
                      settings_data = response.json()
                      settings = {}

                      for setting in settings_data:
                          key_name = setting['setting_key']
                          value = setting['setting_value']

                          # ç±»å‹è½¬æ¢
                          if setting['setting_type'] == 'number':
                              value = int(value)
                          elif setting['setting_type'] == 'boolean':
                              value = value.lower() == 'true'

                          settings[key_name] = value

                      return {
                          'target_count': settings.get('collection_target_count', 3000),
                          'enabled': settings.get('collection_enabled', True),
                          'max_scroll_attempts': settings.get('max_scroll_attempts', 60),
                          'batch_size': settings.get('batch_size', 100),
                          'retry_attempts': settings.get('retry_attempts', 3)
                      }
                  else:
                      print(f"âš ï¸ è·å–è®¾ç½®å¤±è´¥: {response.status_code}")
                      return {
                          'target_count': 3000,
                          'enabled': True,
                          'max_scroll_attempts': 60,
                          'batch_size': 100,
                          'retry_attempts': 3
                      }
              except Exception as e:
                  print(f"âš ï¸ è·å–è®¾ç½®å‡ºé”™: {e}")
                  return {
                      'target_count': 3000,
                      'enabled': True,
                      'max_scroll_attempts': 60,
                      'batch_size': 100,
                      'retry_attempts': 3
                  }

          def collect_toolify_data(target_count=3000, max_scroll_attempts=60):
              """é‡‡é›†Toolifyæ•°æ®"""
              print(f"ğŸš€ å¼€å§‹é‡‡é›†æœ€å¤š {target_count} æ¡å·¥å…·æ•°æ®...")

              driver = setup_driver()
              if not driver:
                  return []

              tools_data = []

              try:
                  url = "https://www.toolify.ai/zh/Best-trending-AI-Tools"
                  print(f"ğŸ“± æ­£åœ¨è®¿é—®: {url}")

                  driver.get(url)
                  time.sleep(10)  # å¢åŠ ç­‰å¾…æ—¶é—´

                  print("ğŸ” å¼€å§‹æ•°æ®é‡‡é›†...")

                  scroll_attempts = 0
                  max_scroll_attempts = 60  # æœ€å¤šæ»šåŠ¨60æ¬¡
                  no_new_data_count = 0

                  while len(tools_data) < target_count and scroll_attempts < max_scroll_attempts:
                      try:
                          current_rows = driver.find_elements(By.CSS_SELECTOR, "tr.el-table__row")

                          if not current_rows:
                              print("âš ï¸ æœªæ‰¾åˆ°æ•°æ®è¡Œï¼Œç­‰å¾…é¡µé¢åŠ è½½...")
                              time.sleep(5)
                              scroll_attempts += 1
                              continue

                          # æå–æ–°æ•°æ®
                          initial_count = len(tools_data)
                          for i in range(len(tools_data), min(len(current_rows), target_count)):
                              try:
                                  row = current_rows[i]

                                  # æå–å·¥å…·æ•°æ®
                                  tool_link = row.find_element(By.CSS_SELECTOR, ".go-tool")
                                  tool_name = tool_link.text.strip()
                                  tool_url = tool_link.get_attribute("href")

                                  cells = row.find_elements(By.TAG_NAME, "td")

                                  tool_data = {
                                      "ranking": i + 1,
                                      "tool_name": tool_name,
                                      "tool_url": f"https://www.toolify.ai{tool_url}" if tool_url.startswith("/") else tool_url,
                                      "monthly_visits": cells[2].find_element(By.TAG_NAME, "span").text.strip() if len(cells) > 2 else "",
                                      "growth": cells[3].find_element(By.TAG_NAME, "span").text.strip() if len(cells) > 3 else "",
                                      "growth_rate": cells[4].find_element(By.TAG_NAME, "span").text.strip() if len(cells) > 4 else "",
                                      "description": cells[5].find_element(By.TAG_NAME, "p").text.strip() if len(cells) > 5 else "",
                                      "tags": cells[6].find_element(By.TAG_NAME, "p").text.strip() if len(cells) > 6 else "",
                                      "collected_at": datetime.now().isoformat(),
                                      "collection_batch": f"github-actions-{datetime.now().strftime('%Y-%m-%d')}"
                                  }

                                  tools_data.append(tool_data)

                                  if len(tools_data) % 50 == 0:
                                      print(f"ğŸ“Š å·²é‡‡é›† {len(tools_data)} æ¡æ•°æ®...")

                              except Exception as e:
                                  print(f"âŒ æå–ç¬¬{i+1}è¡Œæ•°æ®å¤±è´¥: {e}")

                          # æ£€æŸ¥æ˜¯å¦æœ‰æ–°æ•°æ®
                          if len(tools_data) == initial_count:
                              no_new_data_count += 1
                              if no_new_data_count >= 3:
                                  print("ğŸ›‘ è¿ç»­å¤šæ¬¡æ— æ–°æ•°æ®ï¼Œåœæ­¢é‡‡é›†")
                                  break
                          else:
                              no_new_data_count = 0

                          # å¦‚æœè¾¾åˆ°ç›®æ ‡æ•°é‡ï¼Œé€€å‡º
                          if len(tools_data) >= target_count:
                              print(f"ğŸ‰ å·²è¾¾åˆ°ç›®æ ‡æ•°é‡ {target_count} æ¡ï¼")
                              break

                          # æ™ºèƒ½æ»šåŠ¨ç­–ç•¥
                          print(f"ğŸ”„ æ»šåŠ¨åŠ è½½æ›´å¤šæ•°æ®... (ç¬¬{scroll_attempts + 1}æ¬¡)")

                          if scroll_attempts % 3 == 0:
                              driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
                          elif scroll_attempts % 3 == 1:
                              driver.execute_script("window.scrollBy(0, 3000);")
                          else:
                              driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
                              time.sleep(2)
                              driver.execute_script("window.scrollBy(0, -200);")

                          time.sleep(8)  # å¢åŠ ç­‰å¾…æ—¶é—´
                          scroll_attempts += 1

                      except Exception as e:
                          print(f"âŒ æ»šåŠ¨é‡‡é›†å‡ºé”™: {e}")
                          scroll_attempts += 1
                          time.sleep(5)

                  print(f"âœ… é‡‡é›†å®Œæˆï¼å…±è·å– {len(tools_data)} æ¡æ•°æ®")
                  return tools_data[:target_count]

              except Exception as e:
                  print(f"âŒ é‡‡é›†è¿‡ç¨‹å‡ºé”™: {e}")
                  return tools_data

              finally:
                  print("ğŸ”š å…³é—­æµè§ˆå™¨...")
                  driver.quit()

          def upload_to_supabase(tools_data):
              """ä¸Šä¼ æ•°æ®åˆ°Supabase"""
              if not tools_data:
                  print("âŒ æ²¡æœ‰æ•°æ®éœ€è¦ä¸Šä¼ ")
                  return False

              url = os.getenv('SUPABASE_URL')
              key = os.getenv('SUPABASE_ANON_KEY')

              if not url or not key:
                  print("âŒ Supabaseé…ç½®ç¼ºå¤±")
                  return False

              headers = {
                  'apikey': key,
                  'Authorization': f'Bearer {key}',
                  'Content-Type': 'application/json',
                  'Prefer': 'resolution=merge-duplicates'
              }

              # æ‰¹é‡ä¸Šä¼ 
              batch_size = 100
              success_count = 0

              for i in range(0, len(tools_data), batch_size):
                  batch = tools_data[i:i + batch_size]

                  try:
                      response = requests.post(
                          f'{url}/rest/v1/toolify_tools',
                          headers=headers,
                          json=batch,
                          timeout=30
                      )

                      if response.status_code in [200, 201]:
                          success_count += len(batch)
                          print(f"âœ… æ‰¹æ¬¡ {i//batch_size + 1} ä¸Šä¼ æˆåŠŸ ({len(batch)} æ¡)")
                      else:
                          print(f"âŒ æ‰¹æ¬¡ {i//batch_size + 1} ä¸Šä¼ å¤±è´¥: {response.status_code} {response.text}")

                  except Exception as e:
                      print(f"âŒ æ‰¹æ¬¡ {i//batch_size + 1} ä¸Šä¼ å‡ºé”™: {e}")

              print(f"ğŸ“Š ä¸Šä¼ å®Œæˆ: {success_count}/{len(tools_data)} æ¡æ•°æ®æˆåŠŸ")
              return success_count > 0

          def main():
              print("=" * 50)
              print("ğŸ¯ Toolifyç”Ÿäº§ç¯å¢ƒæ•°æ®é‡‡é›†")
              print("=" * 50)

              # ä»æ•°æ®åº“è·å–è®¾ç½®
              settings = get_settings_from_db()
              print(f"ğŸ“‹ é‡‡é›†è®¾ç½®: {settings}")

              # æ£€æŸ¥æ˜¯å¦å¯ç”¨é‡‡é›†
              if not settings['enabled']:
                  print("â¸ï¸ å®šæ—¶é‡‡é›†å·²ç¦ç”¨ï¼Œè·³è¿‡æ‰§è¡Œ")
                  return

              # é‡‡é›†æ•°æ®
              tools_data = collect_toolify_data(
                  target_count=settings['target_count'],
                  max_scroll_attempts=settings['max_scroll_attempts']
              )

              if not tools_data:
                  print("ğŸ’¥ é‡‡é›†å¤±è´¥ï¼Œæ²¡æœ‰è·å–åˆ°æ•°æ®")
                  exit(1)

              # ä¿å­˜æœ¬åœ°å¤‡ä»½
              backup_file = f"toolify-backup-{datetime.now().strftime('%Y-%m-%d')}.json"
              with open(backup_file, 'w', encoding='utf-8') as f:
                  json.dump(tools_data, f, ensure_ascii=False, indent=2)
              print(f"ğŸ’¾ æœ¬åœ°å¤‡ä»½å·²ä¿å­˜: {backup_file}")

              # ä¸Šä¼ åˆ°Supabase
              upload_success = upload_to_supabase(tools_data)

              if upload_success:
                  print("ğŸ‰ æ•°æ®é‡‡é›†å’Œä¸Šä¼ ä»»åŠ¡å®Œæˆï¼")
              else:
                  print("ğŸ’¥ æ•°æ®ä¸Šä¼ å¤±è´¥")
                  exit(1)

          if __name__ == "__main__":
              main()
          EOF

      - name: Run data collection
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}
        run: |
          python scripts/production-collector.py

      - name: Upload backup on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: collection-backup-${{ github.run_number }}
          path: toolify-backup-*.json
          retention-days: 30

      - name: Notify on success
        if: success()
        run: |
          echo "âœ… æ•°æ®é‡‡é›†æˆåŠŸå®Œæˆäº $(date)"
          echo "ğŸ“Š æŸ¥çœ‹æœ€æ–°æ•°æ®: https://your-toolify-app.vercel.app"

      - name: Notify on failure
        if: failure()
        run: |
          echo "âŒ æ•°æ®é‡‡é›†å¤±è´¥äº $(date)"
          echo "ğŸ“‹ è¯·æ£€æŸ¥æ—¥å¿—å’Œå¤‡ä»½æ–‡ä»¶"